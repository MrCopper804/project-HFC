<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HFC Academy - Cipher Carrom</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #000;
            color: #64ffda;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        canvas {
            border: 4px solid #64ffda;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            background: radial-gradient(circle, #0a192f 0%, #000 100%);
            max-width: 95vw;
            max-height: 80vh;
        }
        .neon-text {
            text-shadow: 0 0 10px #64ffda;
        }
        .gold-text {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            text-align: center;
            pointer-events: none;
            width: 100%;
        }
        #modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #64ffda;
            padding: 2rem;
            z-index: 100;
            text-align: center;
            border-radius: 15px;
            min-width: 300px;
        }
        .btn {
            background: transparent;
            border: 1px solid #64ffda;
            color: #64ffda;
            padding: 10px 20px;
            margin-top: 20px;
            cursor: pointer;
            transition: 0.3s;
            pointer-events: auto;
        }
        .btn:hover {
            background: #64ffda;
            color: #000;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-overlay">
        <h2 class="text-xl neon-text">HFC ACADEMY: CIPHER CARROM</h2>
        <div class="flex justify-around mt-2">
            <p id="balance-display" class="gold-text">Balance: --</p>
            <p id="target-display" class="text-2xl font-bold bg-[#64ffda] text-black px-4 rounded">TARGET: ?</p>
        </div>
    </div>

    <canvas id="carromBoard"></canvas>

    <div id="modal">
        <h2 id="modal-title" class="text-2xl mb-4">SYSTEM NOTIFICATION</h2>
        <p id="modal-msg" class="mb-4"></p>
        <button id="modal-btn" class="btn">REBOOT SYSTEM</button>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, onSnapshot, updateDoc, increment } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Firebase Initialization
    const firebaseConfig = JSON.parse(__firebase_config);
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'cipher-carrom';

    const canvas = document.getElementById('carromBoard');
    const ctx = canvas.getContext('2d');
    const BOARD_SIZE = 600;
    const FRICTION = 0.985;
    const WALL_BOUNCE = 0.7;
    const ENTRY_FEE = 10;
    const REWARD = 30;

    let user = null;
    let balance = 0;
    let gameState = 'IDLE'; 
    let targetCipher = null;
    let coins = [];
    let striker = null;
    let aiming = false;
    let dragStart = { x: 0, y: 0 };
    let dragEnd = { x: 0, y: 0 };

    const SYMBOLS = [
        { char: 'A', cipher: '℅' },
        { char: 'B', cipher: '×' },
        { char: 'C', cipher: '[]' },
        { char: 'D', cipher: '^' },
        { char: 'E', cipher: '◈' },
        { char: 'F', cipher: '§' },
        { char: 'G', cipher: '∆' }
    ];

    class Entity {
        constructor(x, y, radius, color, label = '', isStriker = false) {
            this.x = x; this.y = y; this.radius = radius;
            this.color = color; this.label = label;
            this.isStriker = isStriker; this.vx = 0; this.vy = 0;
            this.mass = radius; this.inPocket = false;
        }

        draw() {
            if (this.inPocket) return;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.strokeStyle = '#64ffda';
            ctx.lineWidth = 2;
            ctx.stroke();
            if (this.label) {
                ctx.fillStyle = this.isStriker ? '#000' : '#64ffda';
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, this.x, this.y);
            }
        }

        update() {
            if (this.inPocket) return;
            this.x += this.vx; this.y += this.vy;
            this.vx *= FRICTION; this.vy *= FRICTION;
            if (Math.abs(this.vx) < 0.1) this.vx = 0;
            if (Math.abs(this.vy) < 0.1) this.vy = 0;

            if (this.x - this.radius < 0 || this.x + this.radius > BOARD_SIZE) {
                this.vx *= -WALL_BOUNCE;
                this.x = this.x - this.radius < 0 ? this.radius : BOARD_SIZE - this.radius;
            }
            if (this.y - this.radius < 0 || this.y + this.radius > BOARD_SIZE) {
                this.vy *= -WALL_BOUNCE;
                this.y = this.y - this.radius < 0 ? this.radius : BOARD_SIZE - this.radius;
            }

            const corners = [{x:0,y:0},{x:600,y:0},{x:0,y:600},{x:600,y:600}];
            corners.forEach(p => {
                if (Math.hypot(this.x - p.x, this.y - p.y) < 40) {
                    this.inPocket = true;
                    this.vx = 0; this.vy = 0;
                    handlePocket(this);
                }
            });
        }
    }

    function initGame() {
        canvas.width = BOARD_SIZE;
        canvas.height = BOARD_SIZE;
        targetCipher = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
        document.getElementById('target-display').innerText = `TARGET: ${targetCipher.char}`;
        striker = new Entity(300, 540, 25, '#64ffda', 'S', true);
        coins = SYMBOLS.map((s, i) => {
            const angle = (i / SYMBOLS.length) * Math.PI * 2;
            return new Entity(300 + Math.cos(angle) * 80, 300 + Math.sin(angle) * 80, 20, 'rgba(0,0,0,0.8)', s.cipher);
        });
        gameState = 'IDLE';
    }

    async function handlePocket(entity) {
        if (entity.isStriker) {
            showModal("FOUL!", "Striker pocket ho gaya! Game Over.", false);
        } else if (entity.label === targetCipher.cipher) {
            if (!user) return;
            await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'profile'), { coins: increment(REWARD) });
            showModal("ACCESS GRANTED!", `Sahi Cipher decode kiya! +${REWARD} Coins.`, true);
        } else {
            showModal("SYSTEM BREACH!", "Galat symbol pocket kiya!", false);
        }
    }

    function showModal(title, msg, isWin) {
        gameState = 'GAMEOVER';
        document.getElementById('modal-title').innerText = title;
        document.getElementById('modal-title').className = isWin ? "text-2xl mb-4 neon-text" : "text-2xl mb-4 text-red-500";
        document.getElementById('modal-msg').innerText = msg;
        document.getElementById('modal').style.display = 'block';
    }

    function resolveCollision(e1, e2) {
        const dx = e2.x - e1.x, dy = e2.y - e1.y, dist = Math.hypot(dx, dy);
        if (dist < e1.radius + e2.radius) {
            const nx = dx / dist, ny = dy / dist;
            const rvx = e2.vx - e1.vx, rvy = e2.vy - e1.vy;
            const velNormal = rvx * nx + rvy * ny;
            if (velNormal > 0) return;
            let j = -(1.8) * velNormal / (1/e1.mass + 1/e2.mass);
            e1.vx -= (j * nx) / e1.mass; e1.vy -= (j * ny) / e1.mass;
            e2.vx += (j * nx) / e2.mass; e2.vy += (j * ny) / e2.mass;
            const overlap = (e1.radius + e2.radius) - dist;
            e1.x -= nx * (overlap / 2); e1.y -= ny * (overlap / 2);
            e2.x += nx * (overlap / 2); e2.y += ny * (overlap / 2);
        }
    }

    function gameLoop() {
        ctx.clearRect(0, 0, 600, 600);
        ctx.strokeStyle = 'rgba(100, 255, 218, 0.2)';
        ctx.beginPath(); ctx.arc(300, 300, 120, 0, Math.PI*2); ctx.stroke();
        [ [0,0], [600,0], [0,600], [600,600] ].forEach(p => {
            ctx.beginPath(); ctx.arc(p[0], p[1], 45, 0, Math.PI*2); ctx.fillStyle = '#000'; ctx.fill();
            ctx.strokeStyle = '#64ffda'; ctx.stroke();
        });

        const all = [striker, ...coins];
        all.forEach((e, i) => {
            e.update(); e.draw();
            for (let j = i + 1; j < all.length; j++) 
                if (!e.inPocket && !all[j].inPocket) resolveCollision(e, all[j]);
        });

        if (aiming && gameState === 'IDLE') {
            ctx.beginPath(); ctx.moveTo(striker.x, striker.y);
            const angle = Math.atan2(dragStart.y - dragEnd.y, dragStart.x - dragEnd.x);
            const d = Math.min(Math.hypot(dragStart.x - dragEnd.x, dragStart.y - dragEnd.y), 150);
            ctx.lineTo(striker.x + Math.cos(angle) * d, striker.y + Math.sin(angle) * d);
            ctx.strokeStyle = '#ffd700'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
        }

        if (gameState === 'MOVING' && !all.some(e => Math.abs(e.vx) > 0 || Math.abs(e.vy) > 0)) gameState = 'IDLE';
        requestAnimationFrame(gameLoop);
    }

    async function handleLaunch() {
        if (!aiming) return; aiming = false;
        if (balance < ENTRY_FEE) {
            showModal("INSUFFICIENT COINS", `Kam az kam ${ENTRY_FEE} coins chahiye.`, false);
            return;
        }
        await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'profile'), { coins: increment(-ENTRY_FEE) });
        const power = 0.15;
        striker.vx = (dragStart.x - dragEnd.x) * power;
        striker.vy = (dragStart.y - dragEnd.y) * power;
        gameState = 'MOVING';
    }

    const getM = (e) => {
        const rect = canvas.getBoundingClientRect();
        const t = e.touches ? e.touches[0] : e;
        return { x: (t.clientX - rect.left) * (600/rect.width), y: (t.clientY - rect.top) * (600/rect.height) };
    };

    canvas.addEventListener('mousedown', (e) => {
        const m = getM(e);
        if (gameState === 'IDLE' && Math.hypot(m.x - striker.x, m.y - striker.y) < 50) { aiming = true; dragStart = m; }
    });
    window.addEventListener('mousemove', (e) => { if (aiming) dragEnd = getM(e); });
    window.addEventListener('mouseup', handleLaunch);
    canvas.addEventListener('touchstart', (e) => {
        const m = getM(e);
        if (gameState === 'IDLE' && Math.hypot(m.x - striker.x, m.y - striker.y) < 50) { aiming = true; dragStart = m; }
    });
    window.addEventListener('touchmove', (e) => { if (aiming) dragEnd = getM(e); });
    window.addEventListener('touchend', handleLaunch);

    document.getElementById('modal-btn').onclick = () => location.reload();

    onAuthStateChanged(auth, async (u) => {
        if (u) {
            user = u;
            onSnapshot(doc(db, 'artifacts', appId, 'users', u.uid, 'profile'), (snap) => {
                if (snap.exists()) {
                    balance = snap.data().coins || 0;
                    document.getElementById('balance-display').innerText = `Balance: ${balance}`;
                }
            });
            document.getElementById('game-container').style.opacity = '1';
            initGame(); gameLoop();
        } else {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) await signInWithCustomToken(auth, __initial_auth_token);
            else await signInAnonymously(auth);
        }
    });
</script>
</body>
</html>

