<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HFC Academy - Cipher Carrom</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #000;
            color: #64ffda;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas {
            border: 4px solid #64ffda;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            background: radial-gradient(circle, #0a192f 0%, #000 100%);
            max-width: 95vw;
            max-height: 80vh;
        }
        .neon-text {
            text-shadow: 0 0 10px #64ffda;
        }
        .gold-text {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            text-align: center;
            pointer-events: none;
            width: 100%;
        }
        #modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #64ffda;
            padding: 2rem;
            z-index: 100;
            text-align: center;
            border-radius: 15px;
            min-width: 300px;
        }
        .btn {
            background: transparent;
            border: 1px solid #64ffda;
            color: #64ffda;
            padding: 10px 20px;
            margin-top: 20px;
            cursor: pointer;
            transition: 0.3s;
            pointer-events: auto;
        }
        .btn:hover {
            background: #64ffda;
            color: #000;
        }
        #loader {
            position: fixed;
            inset: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
    </style>
</head>
<body>

<div id="loader">
    <h1 class="text-3xl neon-text mb-4">INITIALIZING CIPHER SYSTEM...</h1>
    <div class="w-48 h-1 bg-gray-800">
        <div class="h-full bg-[#64ffda] animate-pulse"></div>
    </div>
</div>

<div id="game-container">
    <div id="ui-overlay">
        <h2 class="text-xl neon-text">HFC ACADEMY: CIPHER CARROM</h2>
        <div class="flex justify-around mt-2">
            <p id="balance-display" class="gold-text">Balance: --</p>
            <p id="target-display" class="text-2xl font-bold bg-[#64ffda] text-black px-4 rounded">TARGET: ?</p>
        </div>
    </div>

    <canvas id="carromBoard"></canvas>

    <div id="modal">
        <h2 id="modal-title" class="text-2xl mb-4">SYSTEM NOTIFICATION</h2>
        <p id="modal-msg" class="mb-4"></p>
        <button id="modal-btn" class="btn">REBOOT SYSTEM</button>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, onSnapshot, updateDoc, increment } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Firebase Config
    const firebaseConfig = JSON.parse(__firebase_config);
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'cipher-carrom';

    // Game Constants & State
    const canvas = document.getElementById('carromBoard');
    const ctx = canvas.getContext('2d');
    const BOARD_SIZE = 600;
    const FRICTION = 0.985;
    const WALL_BOUNCE = 0.7;
    const ENTRY_FEE = 10;
    const REWARD = 30;

    let user = null;
    let balance = 0;
    let gameState = 'IDLE'; // IDLE, AIMING, MOVING, GAMEOVER
    let targetCipher = null;
    let coins = [];
    let striker = null;
    let aiming = false;
    let dragStart = { x: 0, y: 0 };
    let dragEnd = { x: 0, y: 0 };

    const SYMBOLS = [
        { char: 'A', cipher: '℅' },
        { char: 'B', cipher: '×' },
        { char: 'C', cipher: '[]' },
        { char: 'D', cipher: '^' },
        { char: 'E', cipher: '◈' },
        { char: 'F', cipher: '§' },
        { char: 'G', cipher: '∆' }
    ];

    class Entity {
        constructor(x, y, radius, color, label = '', isStriker = false) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.label = label;
            this.isStriker = isStriker;
            this.vx = 0;
            this.vy = 0;
            this.mass = radius;
            this.inPocket = false;
        }

        draw() {
            if (this.inPocket) return;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.strokeStyle = '#64ffda';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();

            if (this.label) {
                ctx.fillStyle = this.isStriker ? '#000' : '#64ffda';
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, this.x, this.y);
            }
        }

        update() {
            if (this.inPocket) return;

            this.x += this.vx;
            this.y += this.vy;
            this.vx *= FRICTION;
            this.vy *= FRICTION;

            if (Math.abs(this.vx) < 0.1) this.vx = 0;
            if (Math.abs(this.vy) < 0.1) this.vy = 0;

            // Wall Collisions
            if (this.x - this.radius < 0 || this.x + this.radius > BOARD_SIZE) {
                this.vx *= -WALL_BOUNCE;
                this.x = this.x - this.radius < 0 ? this.radius : BOARD_SIZE - this.radius;
            }
            if (this.y - this.radius < 0 || this.y + this.radius > BOARD_SIZE) {
                this.vy *= -WALL_BOUNCE;
                this.y = this.y - this.radius < 0 ? this.radius : BOARD_SIZE - this.radius;
            }

            // Pocket Check
            const corners = [
                {x: 0, y: 0}, {x: BOARD_SIZE, y: 0},
                {x: 0, y: BOARD_SIZE}, {x: BOARD_SIZE, y: BOARD_SIZE}
            ];
            corners.forEach(p => {
                const dist = Math.hypot(this.x - p.x, this.y - p.y);
                if (dist < 40) {
                    this.inPocket = true;
                    this.vx = 0;
                    this.vy = 0;
                    handlePocket(this);
                }
            });
        }
    }

    function initGame() {
        canvas.width = BOARD_SIZE;
        canvas.height = BOARD_SIZE;
        
        // Setup Target
        const selected = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
        targetCipher = selected;
        document.getElementById('target-display').innerText = `TARGET: ${targetCipher.char}`;

        // Setup Striker
        striker = new Entity(BOARD_SIZE / 2, BOARD_SIZE - 60, 25, '#64ffda', 'S', true);

        // Setup Coins
        coins = [];
        const centerX = BOARD_SIZE / 2;
        const centerY = BOARD_SIZE / 2;
        
        SYMBOLS.forEach((s, i) => {
            const angle = (i / SYMBOLS.length) * Math.PI * 2;
            const dist = 80;
            const x = centerX + Math.cos(angle) * dist;
            const y = centerY + Math.sin(angle) * dist;
            coins.push(new Entity(x, y, 20, 'rgba(0,0,0,0.8)', s.cipher));
        });

        gameState = 'IDLE';
    }

    async function handlePocket(entity) {
        if (entity.isStriker) {
            showModal("FOUL!", "Striker pocket ho gaya! Game Over.", false);
            return;
        }

        if (entity.label === targetCipher.cipher) {
            // WIN
            try {
                await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'profile'), {
                    coins: increment(REWARD)
                });
                showModal("ACCESS GRANTED!", `Sahi Cipher decode kiya! +${REWARD} Coins earned.`, true);
            } catch (e) {
                console.error(e);
            }
        } else {
            // WRONG HIT
            showModal("SYSTEM BREACH!", "Galat symbol pocket kiya! System Lockdown.", false);
        }
    }

    function showModal(title, msg, isWin) {
        gameState = 'GAMEOVER';
        const modal = document.getElementById('modal');
        const mTitle = document.getElementById('modal-title');
        const mMsg = document.getElementById('modal-msg');
        
        mTitle.innerText = title;
        mTitle.className = isWin ? "text-2xl mb-4 neon-text" : "text-2xl mb-4 text-red-500";
        mMsg.innerText = msg;
        modal.style.display = 'block';
    }

    function resolveCollision(e1, e2) {
        const dx = e2.x - e1.x;
        const dy = e2.y - e1.y;
        const distance = Math.hypot(dx, dy);

        if (distance < e1.radius + e2.radius) {
            // Normal Vector
            const nx = dx / distance;
            const ny = dy / distance;

            // Relative Velocity
            const rvx = e2.vx - e1.vx;
            const rvy = e2.vy - e1.vy;

            // Velocity along normal
            const velAlongNormal = rvx * nx + rvy * ny;

            if (velAlongNormal > 0) return;

            // Impulse scalar
            const restitution = 0.8;
            let j = -(1 + restitution) * velAlongNormal;
            j /= (1 / e1.mass + 1 / e2.mass);

            // Apply impulse
            const impulseX = j * nx;
            const impulseY = j * ny;

            e1.vx -= (1 / e1.mass) * impulseX;
            e1.vy -= (1 / e1.mass) * impulseY;
            e2.vx += (1 / e2.mass) * impulseX;
            e2.vy += (1 / e2.mass) * impulseY;

            // Anti-sticking
            const overlap = (e1.radius + e2.radius) - distance;
            e1.x -= nx * (overlap / 2);
            e1.y -= ny * (overlap / 2);
            e2.x += nx * (overlap / 2);
            e2.y += ny * (overlap / 2);
        }
    }

    function gameLoop() {
        ctx.clearRect(0, 0, BOARD_SIZE, BOARD_SIZE);

        // Draw Board Design
        ctx.strokeStyle = 'rgba(100, 255, 218, 0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(BOARD_SIZE/2, BOARD_SIZE/2, 120, 0, Math.PI*2);
        ctx.stroke();
        
        // Draw Pockets
        ctx.fillStyle = '#000';
        [ [0,0], [BOARD_SIZE,0], [0,BOARD_SIZE], [BOARD_SIZE,BOARD_SIZE] ].forEach(p => {
            ctx.beginPath();
            ctx.arc(p[0], p[1], 45, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = '#64ffda';
            ctx.stroke();
        });

        const allEntities = [striker, ...coins];
        
        // Update & Collision
        allEntities.forEach((e, i) => {
            e.update();
            e.draw();
            for (let j = i + 1; j < allEntities.length; j++) {
                if (!e.inPocket && !allEntities[j].inPocket) {
                    resolveCollision(e, allEntities[j]);
                }
            }
        });

        // Aiming Line
        if (aiming && gameState === 'IDLE') {
            ctx.beginPath();
            ctx.moveTo(striker.x, striker.y);
            const angle = Math.atan2(dragStart.y - dragEnd.y, dragStart.x - dragEnd.x);
            const dist = Math.min(Math.hypot(dragStart.x - dragEnd.x, dragStart.y - dragEnd.y), 150);
            
            ctx.lineTo(striker.x + Math.cos(angle) * dist, striker.y + Math.sin(angle) * dist);
            ctx.strokeStyle = '#ffd700';
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // State Check: if everything stopped
        if (gameState === 'MOVING') {
            const moving = allEntities.some(e => Math.abs(e.vx) > 0 || Math.abs(e.vy) > 0);
            if (!moving) {
                if (striker.inPocket) {
                   // Handled in handlePocket
                } else {
                    gameState = 'IDLE';
                    // Reset striker position if needed or just keep it there
                }
            }
        }

        requestAnimationFrame(gameLoop);
    }

    // Controls
    function handleInputStart(e) {
        if (gameState !== 'IDLE') return;
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mx = (touch.clientX - rect.left) * scaleX;
        const my = (touch.clientY - rect.top) * scaleY;

        if (Math.hypot(mx - striker.x, my - striker.y) < 50) {
            aiming = true;
            dragStart = { x: mx, y: my };
        }
    }

    function handleInputMove(e) {
        if (!aiming) return;
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        dragEnd = { 
            x: (touch.clientX - rect.left) * scaleX, 
            y: (touch.clientY - rect.top) * scaleY 
        };
    }

    async function handleInputEnd() {
        if (!aiming) return;
        aiming = false;

        if (balance < ENTRY_FEE) {
            showModal("INSUFFICIENT COINS", "Game start karne ke liye 10 coins chahiye.", false);
            return;
        }

        // Deduct Entry Fee
        try {
            await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'profile'), {
                coins: increment(-ENTRY_FEE)
            });
            
            const dx = dragStart.x - dragEnd.x;
            const dy = dragStart.y - dragEnd.y;
            const power = 0.15;
            striker.vx = dx * power;
            striker.vy = dy * power;
            gameState = 'MOVING';
        } catch (e) {
            console.error(e);
        }
    }

    canvas.addEventListener('mousedown', handleInputStart);
    window.addEventListener('mousemove', handleInputMove);
    window.addEventListener('mouseup', handleInputEnd);
    canvas.addEventListener('touchstart', handleInputStart);
    window.addEventListener('touchmove', handleInputMove);
    window.addEventListener('touchend', handleInputEnd);

    document.getElementById('modal-btn').onclick = () => {
        location.reload();
    };

    // Firebase Auth & Data
    onAuthStateChanged(auth, async (u) => {
        if (u) {
            user = u;
            const profileRef = doc(db, 'artifacts', appId, 'users', user.uid, 'profile');
            onSnapshot(profileRef, (snap) => {
                if (snap.exists()) {
                    balance = snap.data().coins || 0;
                    document.getElementById('balance-display').innerText = `Balance: ${balance}`;
                }
            }, (err) => console.error("Firestore error:", err));

            document.getElementById('loader').style.display = 'none';
            initGame();
            gameLoop();
        } else {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        }
    });

</script>

</body>
</html>

